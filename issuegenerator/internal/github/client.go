// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package github handles interaction with Github through the [Client].
package github

import (
	"context"
	"encoding"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"

	"github.com/google/go-github/v75/github"
	"go.uber.org/zap"
	"golang.org/x/oauth2"

	"go.opentelemetry.io/build-tools/issuegenerator/internal/report"
)

const (
	// Keys of required environment variables
	githubOwnerAndRepository = "GITHUB_REPOSITORY"
	githubWorkflow           = "GITHUB_ACTION"
	githubAPITokenKey        = "GITHUB_TOKEN" // #nosec G101
	githubSHAKey             = "GITHUB_SHA"

	githubOwner      = "githubOwner"
	githubRepository = "githubRepository"

	// Variables used to build workflow URL.
	githubServerURL    = "GITHUB_SERVER_URL"
	githubRunID        = "GITHUB_RUN_ID"
	autoGeneratedLabel = "generated-by-issuegenerator"
	issueTitleTemplate = `[${module}]: Report for failed tests on main`
	issueBodyTemplate  = `
Auto-generated report for ${jobName} job build.

Link to failed build: ${linkToBuild}
Commit: ${commit}
PR: ${prNumber}

### Component(s)
${component}

${failedTests}

**Note**: Information about any subsequent build failures that happen while
this issue is open, will be added as comments with more information to this issue.
`
	issueCommentTemplate = `
Link to latest failed build: ${linkToBuild}
Commit: ${commit}

${failedTests}
`
	prCommentTemplate = `@${prAuthor} some tests are failing on main after these changes.  
Details: ${issueLink}  
Please take a look when you get a chance. Thanks!
`
)

// CommaSeparatedList is a custom type for parsing comma-separated values.
type CommaSeparatedList []string

var _ encoding.TextMarshaler = (*CommaSeparatedList)(nil)

// MarshalText is needed for flag.TextVar support.
func (c CommaSeparatedList) MarshalText() ([]byte, error) {
	return []byte(strings.Join(c, ",")), nil
}

var _ encoding.TextUnmarshaler = (*CommaSeparatedList)(nil)

// UnmarshalText is needed for flag.TextVar support.
func (c *CommaSeparatedList) UnmarshalText(text []byte) error {
	for _, key := range strings.Split(string(text), ",") {
		key = strings.TrimSpace(key)
		if key == "" {
			return errors.New("empty key in comma-separated list")
		}
		*c = append(*c, key)
	}
	return nil
}

// ClientConfig includes all the configuration to create a [Client].
type ClientConfig struct {
	Labels CommaSeparatedList
}

func (c *ClientConfig) labelsCopy() []string {
	newSlice := make([]string, len(c.Labels))
	copy(newSlice, c.Labels)
	return newSlice
}

// Client for Github interaction
type Client struct {
	logger       *zap.Logger
	client       *github.Client
	envVariables map[string]string
	cfg          ClientConfig
}

// NewClient creates a new client.
func NewClient(ctx context.Context, logger *zap.Logger, cfg ClientConfig) (*Client, error) {
	env, err := getRequiredEnv()
	if err != nil {
		return nil, err
	}
	ts := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: env[githubAPITokenKey]})
	tc := oauth2.NewClient(ctx, ts)
	cfg.Labels = append(cfg.Labels, autoGeneratedLabel)
	return &Client{
		logger:       logger,
		client:       github.NewClient(tc),
		envVariables: env,
		cfg:          cfg,
	}, nil
}

// getRequiredEnv loads required environment variables for the main method.
// Some of the environment variables are built-in in Github Actions, whereas others
// need to be configured. See https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables#default-environment-variables
// for a list of built-in environment variables.
func getRequiredEnv() (map[string]string, error) {
	env := map[string]string{}

	// As shown in the docs, the GITHUB_REPOSITORY environment variable is of the form
	// owner/repository.
	// See https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables#default-environment-variables:~:text=or%20tag.-,GITHUB_REPOSITORY,-The%20owner%20and
	ownerAndRepository := strings.Split(os.Getenv(githubOwnerAndRepository), "/")
	env[githubOwner] = ownerAndRepository[0]
	env[githubRepository] = ownerAndRepository[1]
	env[githubWorkflow] = os.Getenv(githubWorkflow)
	env[githubServerURL] = os.Getenv(githubServerURL)
	env[githubRunID] = os.Getenv(githubRunID)
	env[githubAPITokenKey] = os.Getenv(githubAPITokenKey)
	env[githubSHAKey] = os.Getenv(githubSHAKey)

	for k, v := range env {
		if v == "" {
			return nil, fmt.Errorf("required environment variable %q not set", k)
		}
	}

	return env, nil
}

// GetExistingIssue gathers an existing GitHub Issue related to previous failures
// of the same module.
func (c *Client) GetExistingIssue(ctx context.Context, module string) *github.Issue {

	componentName := getComponent(trimModule(c.envVariables[githubOwner], c.envVariables[githubRepository], module))
	issues, response, err := c.client.Issues.ListByRepo(
		ctx,
		c.envVariables[githubOwner],
		c.envVariables[githubRepository],
		&github.IssueListByRepoOptions{
			State:  "open",
			Labels: []string{autoGeneratedLabel, componentName},
		},
	)
	if err != nil {
		c.logger.Fatal("Failed to search GitHub Issues", zap.Error(err))
	}

	if response.StatusCode != http.StatusOK {
		c.handleBadResponses(response)
	}

	if len(issues) > 0 {
		if len(issues) > 1 {
			issueLinks := make([]string, len(issues))
			for i, issue := range issues {
				if issue.HTMLURL != nil {
					issueLinks[i] = *issue.HTMLURL
				}
				c.logger.Warn(
					"Multiple existing Issues found for the same component",
					zap.Strings("issue_links", issueLinks),
				)
			}
		}
		return issues[0]
	}
	return nil
}

// CommentOnIssue adds a new comment on an existing GitHub issue with
// information about the latest failure. This method is expected to be
// called only if there's an existing open Issue for the current job.
func (c *Client) CommentOnIssue(ctx context.Context, r report.Report, issue *github.Issue) *github.IssueComment {
	// Get commit message and extract PR number
	commitMessage := c.getCommitMessage(ctx)
	prNumber := c.extractPRNumberFromCommitMessage(commitMessage)

	body := os.Expand(issueCommentTemplate, templateHelper(c.envVariables, r, prNumber))

	issueComment, response, err := c.client.Issues.CreateComment(
		ctx,
		c.envVariables[githubOwner],
		c.envVariables[githubRepository],
		*issue.Number,
		&github.IssueComment{
			Body: &body,
		},
	)
	if err != nil {
		c.logger.Fatal("Failed to search GitHub Issues", zap.Error(err))
	}

	if response.StatusCode != http.StatusCreated {
		c.handleBadResponses(response)
	}

	// Also comment on the PR with a link to this comment
	if prNumber > 0 && issueComment != nil && issueComment.HTMLURL != nil {
		if prAuthor := c.GetPRAuthor(ctx, prNumber); prAuthor != "" {
			_ = c.CommentOnPR(ctx, prNumber, prAuthor, *issueComment.HTMLURL)
		}
	}

	return issueComment
}

func trimModule(owner, repo, module string) string {
	return strings.TrimPrefix(module, fmt.Sprintf("github.com/%s/%s/", owner, repo))
}

func getComponent(module string) string {
	parts := strings.Split(module, "/")
	if len(parts) >= 2 {
		componentName := parts[1]
		for _, suffix := range []string{"receiver", "exporter", "processor", "extension", "connector"} {
			// component name will always be more than just the suffix, we are checking just to be safe
			if strings.HasSuffix(componentName, suffix) && len(componentName) > len(suffix) {
				componentName = strings.TrimSuffix(componentName, suffix)
				break
			}
		}
		return parts[0] + "/" + componentName
	}
	return module
}

func templateHelper(env map[string]string, r report.Report, prNumber int) func(string) string {
	return func(param string) string {
		switch param {
		case "jobName":
			return "`" + env[githubWorkflow] + "`"
		case "linkToBuild":
			return fmt.Sprintf("%s/%s/%s/actions/runs/%s", env[githubServerURL], env[githubOwner], env[githubRepository], env[githubRunID])
		case "failedTests":
			return r.FailedTestsMD()
		case "component":
			trimmedModule := trimModule(env[githubOwner], env[githubRepository], r.Module)
			return getComponent(trimmedModule)
		case "commit":
			return shortSha(env[githubSHAKey])
		case "prNumber":
			if prNumber > 0 {
				return fmt.Sprintf("#%d", prNumber)
			}
			return "N/A"
		default:
			return ""
		}
	}
}

// shortSha returns the first 7 characters of a full Git commit SHA
func shortSha(sha string) string {
	if len(sha) >= 7 {
		return sha[:7]
	}
	return sha
}

// getCommitMessage fetches the commit message
func (c *Client) getCommitMessage(ctx context.Context) string {
	commit, response, err := c.client.Repositories.GetCommit(
		ctx,
		c.envVariables[githubOwner],
		c.envVariables[githubRepository],
		c.envVariables[githubSHAKey],
		&github.ListOptions{},
	)
	if err != nil {
		c.logger.Warn("Failed to get commit message from GitHub API",
			zap.String("sha", c.envVariables[githubSHAKey]),
			zap.Error(err),
		)
		return ""
	}

	if response.StatusCode != http.StatusOK {
		c.logger.Warn("Unexpected response when fetching commit",
			zap.Int("status_code", response.StatusCode),
			zap.String("sha", c.envVariables[githubSHAKey]),
		)
		return ""
	}

	if commit.Commit != nil {
		return *commit.Commit.Message
	}

	return ""
}

// GetPRAuthor fetches the author of a pull request
func (c *Client) GetPRAuthor(ctx context.Context, prNumber int) string {
	if prNumber <= 0 {
		return ""
	}

	pr, response, err := c.client.PullRequests.Get(
		ctx,
		c.envVariables[githubOwner],
		c.envVariables[githubRepository],
		prNumber,
	)
	if err != nil {
		c.logger.Warn("Failed to get PR details from GitHub API",
			zap.Int("pr_number", prNumber),
			zap.Error(err),
		)
		return ""
	}

	if response.StatusCode != http.StatusOK {
		c.logger.Warn("Unexpected response when fetching PR",
			zap.Int("status_code", response.StatusCode),
			zap.Int("pr_number", prNumber),
		)
		return ""
	}

	if pr.User != nil && pr.User.Login != nil {
		return *pr.User.Login
	}

	return ""
}

// CommentOnPR adds a comment to a pull request to notify the author about failing tests
func (c *Client) CommentOnPR(ctx context.Context, prNumber int, prAuthor string, issueURL string) *github.IssueComment {
	if prNumber <= 0 || prAuthor == "" {
		c.logger.Warn("Cannot comment on PR: missing PR number or author",
			zap.Int("pr_number", prNumber),
			zap.String("pr_author", prAuthor),
		)
		return nil
	}

	body := os.Expand(prCommentTemplate, func(param string) string {
		return prTemplateHelper(param, prAuthor, issueURL)
	})

	prComment, response, err := c.client.Issues.CreateComment(
		ctx,
		c.envVariables[githubOwner],
		c.envVariables[githubRepository],
		prNumber,
		&github.IssueComment{
			Body: &body,
		},
	)
	if err != nil {
		c.logger.Warn("Failed to comment on PR",
			zap.Int("pr_number", prNumber),
			zap.Error(err),
		)
		return nil
	}

	if response.StatusCode != http.StatusCreated {
		c.logger.Warn("Unexpected response when commenting on PR",
			zap.Int("status_code", response.StatusCode),
			zap.Int("pr_number", prNumber),
		)
		return nil
	}

	return prComment
}

func (c *Client) extractPRNumberFromCommitMessage(commitMsg string) int {
	// Only consider the first line of the commit message.
	firstLine := strings.SplitN(commitMsg, "\n", 2)[0]

	// cases matched :
	// - (#123)
	// - Merge pull request #123
	// - (#123): some description
	// - pull request #123
	prRegex := regexp.MustCompile(`(?i)(?:merge pull request #|pull request #|\(#)(\d+)\)?`)
	matches := prRegex.FindStringSubmatch(firstLine)

	if len(matches) >= 2 {
		prNumber, err := strconv.Atoi(matches[1])
		if err != nil {
			c.logger.Warn("Failed to convert PR number to integer",
				zap.String("pr_string", matches[1]),
				zap.Error(err),
			)
			return 0
		}
		return prNumber
	}

	c.logger.Warn("No PR number found in commit message",
		zap.String("first_line", firstLine),
	)
	return 0
}

// CreateIssue creates a new GitHub Issue corresponding to a build failure.
func (c *Client) CreateIssue(ctx context.Context, r report.Report) *github.Issue {
	trimmedModule := trimModule(c.envVariables[githubOwner], c.envVariables[githubRepository], r.Module)
	title := strings.Replace(issueTitleTemplate, "${module}", trimmedModule, 1)

	// Get commit message and extract PR number
	commitMessage := c.getCommitMessage(ctx)
	prNumber := c.extractPRNumberFromCommitMessage(commitMessage)

	body := os.Expand(issueBodyTemplate, templateHelper(c.envVariables, r, prNumber))
	componentName := getComponent(trimmedModule)

	issueLabels := c.cfg.labelsCopy()
	issueLabels = append(issueLabels, componentName)

	issue, response, err := c.client.Issues.Create(
		ctx,
		c.envVariables[githubOwner],
		c.envVariables[githubRepository],
		&github.IssueRequest{
			Title:  &title,
			Body:   &body,
			Labels: &issueLabels,
		})
	if err != nil {
		c.logger.Fatal("Failed to create GitHub Issue", zap.Error(err))
	}

	if response.StatusCode != http.StatusCreated {
		c.handleBadResponses(response)
	}

	// After creating the issue, also comment on the PR  with a link to the created issue
	if prNumber > 0 && issue != nil && issue.HTMLURL != nil {
		if prAuthor := c.GetPRAuthor(ctx, prNumber); prAuthor != "" {
			_ = c.CommentOnPR(ctx, prNumber, prAuthor, *issue.HTMLURL)
		}
	}

	return issue
}

func prTemplateHelper(param string, prAuthor string, issueURL string) string {
	switch param {
	case "prAuthor":
		return prAuthor
	case "issueLink":
		return issueURL
	default:
		return ""
	}
}

func (c *Client) handleBadResponses(response *github.Response) {
	body, _ := io.ReadAll(response.Body)
	c.logger.Fatal(
		"Unexpected response from GitHub",
		zap.Int("status_code", response.StatusCode),
		zap.String("response", string(body)),
		zap.String("url", response.Request.URL.String()),
	)
}
