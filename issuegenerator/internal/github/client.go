// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package github handles interaction with Github through the [Client].
package github

import (
	"context"
	"encoding"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"

	"github.com/google/go-github/github"
	"go.uber.org/zap"
	"golang.org/x/oauth2"

	"go.opentelemetry.io/build-tools/issuegenerator/internal/report"
)

const (
	// Keys of required environment variables
	githubOwnerAndRepository = "GITHUB_REPOSITORY"
	githubWorkflow           = "GITHUB_ACTION"
	githubAPITokenKey        = "GITHUB_TOKEN" // #nosec G101
	githubSHAKey             = "GITHUB_SHA"

	githubOwner      = "githubOwner"
	githubRepository = "githubRepository"

	// Variables used to build workflow URL.
	githubServerURL    = "GITHUB_SERVER_URL"
	githubRunID        = "GITHUB_RUN_ID"
	autoGeneratedLabel = "generated-by-issuegenerator"
	issueTitleTemplate = `[${module}]: Report for failed tests on main`
	issueBodyTemplate  = `
Auto-generated report for ${jobName} job build.

Link to failed build: ${linkToBuild}
Commit: ${commit}

### Component(s)
${component}

${failedTests}

**Note**: Information about any subsequent build failures that happen while
this issue is open, will be added as comments with more information to this issue.
`
	issueCommentTemplate = `
Link to latest failed build: ${linkToBuild}
Commit: ${commit}

${failedTests}
`
)

// CommaSeparatedList is a custom type for parsing comma-separated values.
type CommaSeparatedList []string

var _ encoding.TextMarshaler = (*CommaSeparatedList)(nil)

// MarshalText is needed for flag.TextVar support.
func (c CommaSeparatedList) MarshalText() ([]byte, error) {
	return []byte(strings.Join(c, ",")), nil
}

var _ encoding.TextUnmarshaler = (*CommaSeparatedList)(nil)

// UnmarshalText is needed for flag.TextVar support.
func (c *CommaSeparatedList) UnmarshalText(text []byte) error {
	for _, key := range strings.Split(string(text), ",") {
		key = strings.TrimSpace(key)
		if key == "" {
			return errors.New("empty key in comma-separated list")
		}
		*c = append(*c, key)
	}
	return nil
}

// ClientConfig includes all the configuration to create a [Client].
type ClientConfig struct {
	Labels CommaSeparatedList
}

func (c *ClientConfig) labelsCopy() []string {
	newSlice := make([]string, len(c.Labels))
	copy(newSlice, c.Labels)
	return newSlice
}

// Client for Github interaction
type Client struct {
	logger       *zap.Logger
	client       *github.Client
	envVariables map[string]string
	cfg          ClientConfig
}

// NewClient creates a new client.
func NewClient(ctx context.Context, logger *zap.Logger, cfg ClientConfig) (*Client, error) {
	env, err := getRequiredEnv()
	if err != nil {
		return nil, err
	}
	ts := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: env[githubAPITokenKey]})
	tc := oauth2.NewClient(ctx, ts)
	cfg.Labels = append(cfg.Labels, autoGeneratedLabel)
	return &Client{
		logger:       logger,
		client:       github.NewClient(tc),
		envVariables: env,
		cfg:          cfg,
	}, nil
}

// getRequiredEnv loads required environment variables for the main method.
// Some of the environment variables are built-in in Github Actions, whereas others
// need to be configured. See https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables#default-environment-variables
// for a list of built-in environment variables.
func getRequiredEnv() (map[string]string, error) {
	env := map[string]string{}

	// As shown in the docs, the GITHUB_REPOSITORY environment variable is of the form
	// owner/repository.
	// See https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables#default-environment-variables:~:text=or%20tag.-,GITHUB_REPOSITORY,-The%20owner%20and
	ownerAndRepository := strings.Split(os.Getenv(githubOwnerAndRepository), "/")
	env[githubOwner] = ownerAndRepository[0]
	env[githubRepository] = ownerAndRepository[1]
	env[githubWorkflow] = os.Getenv(githubWorkflow)
	env[githubServerURL] = os.Getenv(githubServerURL)
	env[githubRunID] = os.Getenv(githubRunID)
	env[githubAPITokenKey] = os.Getenv(githubAPITokenKey)
	env[githubSHAKey] = os.Getenv(githubSHAKey)

	for k, v := range env {
		if v == "" {
			return nil, fmt.Errorf("required environment variable %q not set", k)
		}
	}

	return env, nil
}

// GetExistingIssue gathers an existing GitHub Issue related to previous failures
// of the same module.
func (c *Client) GetExistingIssue(ctx context.Context, module string) *github.Issue {

	componentName := getComponent(trimModule(c.envVariables[githubOwner], c.envVariables[githubRepository], module))
	issues, response, err := c.client.Issues.ListByRepo(
		ctx,
		c.envVariables[githubOwner],
		c.envVariables[githubRepository],
		&github.IssueListByRepoOptions{
			State:  "open",
			Labels: []string{autoGeneratedLabel, componentName},
		},
	)
	if err != nil {
		c.logger.Fatal("Failed to search GitHub Issues", zap.Error(err))
	}

	if response.StatusCode != http.StatusOK {
		c.handleBadResponses(response)
	}

	if len(issues) > 0 {
		if len(issues) > 1 {
			issueLinks := make([]string, len(issues))
			for i, issue := range issues {
				if issue.HTMLURL != nil {
					issueLinks[i] = *issue.HTMLURL
				}
				c.logger.Warn(
					"Multiple existing Issues found for the same component",
					zap.Strings("issue_links", issueLinks),
				)
			}
		}
		return issues[0]
	}
	return nil
}

// CommentOnIssue adds a new comment on an existing GitHub issue with
// information about the latest failure. This method is expected to be
// called only if there's an existing open Issue for the current job.
func (c *Client) CommentOnIssue(ctx context.Context, r report.Report, issue *github.Issue) *github.IssueComment {
	body := os.Expand(issueCommentTemplate, templateHelper(c.envVariables, r))

	issueComment, response, err := c.client.Issues.CreateComment(
		ctx,
		c.envVariables[githubOwner],
		c.envVariables[githubRepository],
		*issue.Number,
		&github.IssueComment{
			Body: &body,
		},
	)
	if err != nil {
		c.logger.Fatal("Failed to search GitHub Issues", zap.Error(err))
	}

	if response.StatusCode != http.StatusCreated {
		c.handleBadResponses(response)
	}

	return issueComment
}

func trimModule(owner, repo, module string) string {
	return strings.TrimPrefix(module, fmt.Sprintf("github.com/%s/%s/", owner, repo))
}

func getComponent(module string) string {
	parts := strings.Split(module, "/")
	if len(parts) >= 2 {
		return strings.Join(parts[:2], "/")
	}
	return module
}

func templateHelper(env map[string]string, r report.Report) func(string) string {
	return func(param string) string {
		switch param {
		case "jobName":
			return "`" + env[githubWorkflow] + "`"
		case "linkToBuild":
			return fmt.Sprintf("%s/%s/%s/actions/runs/%s", env[githubServerURL], env[githubOwner], env[githubRepository], env[githubRunID])
		case "failedTests":
			return r.FailedTestsMD()
		case "component":
			trimmedModule := trimModule(env[githubOwner], env[githubRepository], r.Module)
			return getComponent(trimmedModule)
		case "commit":
			return shortSha(env[githubSHAKey])
		default:
			return ""
		}
	}
}

// shortSha returns the first 7 characters of a full Git commit SHA
func shortSha(sha string) string {
	if len(sha) >= 7 {
		return sha[:7]
	}
	return sha 
}

// CreateIssue creates a new GitHub Issue corresponding to a build failure.
func (c *Client) CreateIssue(ctx context.Context, r report.Report) *github.Issue {
	trimmedModule := trimModule(c.envVariables[githubOwner], c.envVariables[githubRepository], r.Module)
	title := strings.Replace(issueTitleTemplate, "${module}", trimmedModule, 1)
	body := os.Expand(issueBodyTemplate, templateHelper(c.envVariables, r))
	componentName := getComponent(trimmedModule)

	issueLabels := c.cfg.labelsCopy()
	issueLabels = append(issueLabels, componentName)

	issue, response, err := c.client.Issues.Create(
		ctx,
		c.envVariables[githubOwner],
		c.envVariables[githubRepository],
		&github.IssueRequest{
			Title:  &title,
			Body:   &body,
			Labels: &issueLabels,
		})
	if err != nil {
		c.logger.Fatal("Failed to create GitHub Issue", zap.Error(err))
	}

	if response.StatusCode != http.StatusCreated {
		c.handleBadResponses(response)
	}

	return issue
}

func (c *Client) handleBadResponses(response *github.Response) {
	body, _ := io.ReadAll(response.Body)
	c.logger.Fatal(
		"Unexpected response from GitHub",
		zap.Int("status_code", response.StatusCode),
		zap.String("response", string(body)),
		zap.String("url", response.Request.URL.String()),
	)
}
